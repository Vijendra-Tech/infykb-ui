import { db } from '@/lib/database';
import type { GitHubIssue, GitHubPullRequest, GitHubDiscussion } from '@/lib/database';
import type { GitHubIngestionResult } from './github-service';

export interface GitHubDataStorageOptions {
  sourceId: string;
  organizationId: string;
  projectId?: string;
  repository: string;
}

export class GitHubDataService {
  /**
   * Store GitHub data (issues, PRs, discussions) in the Dexie database
   */
  async storeGitHubData(
    data: GitHubIngestionResult,
    options: GitHubDataStorageOptions
  ): Promise<{
    storedIssues: number;
    storedPullRequests: number;
    storedDiscussions: number;
    errors: string[];
  }> {
    const { sourceId, organizationId, projectId, repository } = options;
    const errors: string[] = [];
    let storedIssues = 0;
    let storedPullRequests = 0;
    let storedDiscussions = 0;

    try {
      // Clear existing data for this source before storing new data
      await this.clearSourceData(sourceId);

      // Store GitHub Issues
      if (data.issues.length > 0) {
        try {
          const issueRecords: Omit<GitHubIssue, 'id'>[] = data.issues.map(issue => ({
            uuid: '', // Will be auto-generated by hook
            githubId: issue.id,
            number: issue.number,
            title: issue.title,
            body: issue.body || undefined,
            state: issue.state,
            html_url: issue.html_url,
            repository,
            user: issue.user,
            labels: issue.labels,
            assignees: issue.assignees || [],
            created_at: issue.created_at,
            updated_at: issue.updated_at,
            comments: 0, // GitHub API doesn't return this in the basic call
            syncedAt: new Date(),
            organizationId,
            projectId,
            sourceId,
            metadata: {
              originalData: issue
            }
          }));

          await db.githubIssues.bulkAdd(issueRecords);
          storedIssues = issueRecords.length;
          console.log(`Stored ${storedIssues} GitHub issues`);
        } catch (error) {
          const errorMsg = `Failed to store GitHub issues: ${error instanceof Error ? error.message : 'Unknown error'}`;
          errors.push(errorMsg);
          console.error(errorMsg, error);
        }
      }

      // Store GitHub Pull Requests
      if (data.pullRequests.length > 0) {
        try {
          const prRecords: Omit<GitHubPullRequest, 'id'>[] = data.pullRequests.map(pr => ({
            uuid: '', // Will be auto-generated by hook
            githubId: pr.id,
            number: pr.number,
            title: pr.title,
            body: pr.body || undefined,
            state: pr.state,
            html_url: pr.html_url,
            repository,
            user: pr.user,
            head: pr.head,
            base: pr.base,
            created_at: pr.created_at,
            updated_at: pr.updated_at,
            merged_at: pr.merged_at || undefined,
            syncedAt: new Date(),
            organizationId,
            projectId,
            sourceId,
            metadata: {
              originalData: pr
            }
          }));

          await db.githubPullRequests.bulkAdd(prRecords);
          storedPullRequests = prRecords.length;
          console.log(`Stored ${storedPullRequests} GitHub pull requests`);
        } catch (error) {
          const errorMsg = `Failed to store GitHub pull requests: ${error instanceof Error ? error.message : 'Unknown error'}`;
          errors.push(errorMsg);
          console.error(errorMsg, error);
        }
      }

      // Store GitHub Discussions
      if (data.discussions.length > 0) {
        try {
          const discussionRecords: Omit<GitHubDiscussion, 'id'>[] = data.discussions.map(discussion => ({
            uuid: '', // Will be auto-generated by hook
            githubId: discussion.id,
            number: discussion.number,
            title: discussion.title,
            body: discussion.body,
            state: discussion.state,
            url: discussion.url,
            repository,
            author: discussion.author,
            category: discussion.category,
            created_at: discussion.created_at,
            updated_at: discussion.updated_at,
            syncedAt: new Date(),
            organizationId,
            projectId,
            sourceId,
            metadata: {
              originalData: discussion
            }
          }));

          await db.githubDiscussions.bulkAdd(discussionRecords);
          storedDiscussions = discussionRecords.length;
          console.log(`Stored ${storedDiscussions} GitHub discussions`);
        } catch (error) {
          const errorMsg = `Failed to store GitHub discussions: ${error instanceof Error ? error.message : 'Unknown error'}`;
          errors.push(errorMsg);
          console.error(errorMsg, error);
        }
      }

      console.log(`GitHub data storage completed for source ${sourceId}:`, {
        issues: storedIssues,
        pullRequests: storedPullRequests,
        discussions: storedDiscussions,
        errors: errors.length
      });

      return {
        storedIssues,
        storedPullRequests,
        storedDiscussions,
        errors
      };

    } catch (error) {
      const errorMsg = `Failed to store GitHub data: ${error instanceof Error ? error.message : 'Unknown error'}`;
      errors.push(errorMsg);
      console.error(errorMsg, error);
      
      return {
        storedIssues,
        storedPullRequests,
        storedDiscussions,
        errors
      };
    }
  }

  /**
   * Clear all GitHub data for a specific source
   */
  async clearSourceData(sourceId: string): Promise<void> {
    try {
      // Clear issues
      const issueIds = await db.githubIssues
        .where('sourceId')
        .equals(sourceId)
        .primaryKeys();
      if (issueIds.length > 0) {
        await db.githubIssues.bulkDelete(issueIds);
      }

      // Clear pull requests
      const prIds = await db.githubPullRequests
        .where('sourceId')
        .equals(sourceId)
        .primaryKeys();
      if (prIds.length > 0) {
        await db.githubPullRequests.bulkDelete(prIds);
      }

      // Clear discussions
      const discussionIds = await db.githubDiscussions
        .where('sourceId')
        .equals(sourceId)
        .primaryKeys();
      if (discussionIds.length > 0) {
        await db.githubDiscussions.bulkDelete(discussionIds);
      }

      console.log(`Cleared existing GitHub data for source ${sourceId}`);
    } catch (error) {
      console.error(`Failed to clear GitHub data for source ${sourceId}:`, error);
      throw error;
    }
  }

  /**
   * Get all GitHub data for a specific source
   */
  async getSourceData(sourceId: string): Promise<{
    issues: GitHubIssue[];
    pullRequests: GitHubPullRequest[];
    discussions: GitHubDiscussion[];
  }> {
    try {
      const [issues, pullRequests, discussions] = await Promise.all([
        db.githubIssues.where('sourceId').equals(sourceId).toArray(),
        db.githubPullRequests.where('sourceId').equals(sourceId).toArray(),
        db.githubDiscussions.where('sourceId').equals(sourceId).toArray()
      ]);

      return {
        issues,
        pullRequests,
        discussions
      };
    } catch (error) {
      console.error(`Failed to get GitHub data for source ${sourceId}:`, error);
      throw error;
    }
  }

  /**
   * Search GitHub issues across all sources or a specific source
   */
  async searchIssues(query: string, sourceId?: string): Promise<GitHubIssue[]> {
    try {
      let issues: GitHubIssue[];

      if (sourceId) {
        issues = await db.githubIssues.where('sourceId').equals(sourceId).toArray();
      } else {
        issues = await db.githubIssues.toArray();
      }

      const searchTerms = query.toLowerCase().split(' ');
      
      return issues.filter(issue => {
        const searchText = `${issue.title} ${issue.body || ''}`.toLowerCase();
        return searchTerms.some(term => searchText.includes(term));
      });
    } catch (error) {
      console.error('Failed to search GitHub issues:', error);
      throw error;
    }
  }

  /**
   * Get storage statistics
   */
  async getStorageStats(): Promise<{
    totalIssues: number;
    totalPullRequests: number;
    totalDiscussions: number;
    sourceStats: Array<{
      sourceId: string;
      issues: number;
      pullRequests: number;
      discussions: number;
    }>;
  }> {
    try {
      const [allIssues, allPullRequests, allDiscussions] = await Promise.all([
        db.githubIssues.toArray(),
        db.githubPullRequests.toArray(),
        db.githubDiscussions.toArray()
      ]);

      // Group by source
      const sourceMap = new Map<string, { issues: number; pullRequests: number; discussions: number }>();

      allIssues.forEach(issue => {
        if (issue.sourceId) {
          const stats = sourceMap.get(issue.sourceId) || { issues: 0, pullRequests: 0, discussions: 0 };
          stats.issues++;
          sourceMap.set(issue.sourceId, stats);
        }
      });

      allPullRequests.forEach(pr => {
        if (pr.sourceId) {
          const stats = sourceMap.get(pr.sourceId) || { issues: 0, pullRequests: 0, discussions: 0 };
          stats.pullRequests++;
          sourceMap.set(pr.sourceId, stats);
        }
      });

      allDiscussions.forEach(discussion => {
        if (discussion.sourceId) {
          const stats = sourceMap.get(discussion.sourceId) || { issues: 0, pullRequests: 0, discussions: 0 };
          stats.discussions++;
          sourceMap.set(discussion.sourceId, stats);
        }
      });

      const sourceStats = Array.from(sourceMap.entries()).map(([sourceId, stats]) => ({
        sourceId,
        ...stats
      }));

      return {
        totalIssues: allIssues.length,
        totalPullRequests: allPullRequests.length,
        totalDiscussions: allDiscussions.length,
        sourceStats
      };
    } catch (error) {
      console.error('Failed to get storage stats:', error);
      throw error;
    }
  }
}

export const githubDataService = new GitHubDataService();
